[[overview]]
== Overview

=== Introduction to JSON
This section presents JSON. Afterwords, it discusses about important questions such as what JSON offers, when a JSON encoding offers an advantage (e.g. in simplicity and flexibility) to an XML encoding, and when XML encodings can provide a better solution (e.g. adding more expressivity and robustness). Finally it presents some precisions that OGC can add on top of the basic JSON definition to ensure better interoperability of applications using JSON.

[[The_JSON_format]]
=== The JSON format
JSON is a very simple data model that can represent four primitives (strings, numbers, booleans (_true_ or _false_) and _null_) and includes two structured types (objects and arrays). Strings are enclosed in _quotation marks_, numbers does not have quotation marks, objects are enclosed in curly brackets "{}" and a arrays are enclosed in square brackets "[]". An object is an unordered collection of zero or more parameters (name and value pairs, separated by a colon), where a name is a string and a value is a primitive or a structured type. Parameters are separated by commas and usually each of them is written in a different line. An array is an ordered sequence of zero or more values (primitives or structured types, separated by commas). 

The fact that the names of properties are enclosed in _quotation marks_ and the use of ":" are marks of identity that helps to visually identify that text documents are actually instances written in JSON (instead of e.g. C++ or Java data structures).

.Example of JSON document providing some metadata about a picture.
[source,json]
----
{
    "width":  800,
    "height": 600,
    "title":  "View from 15th Floor",
    "thumbnail": {
        "url":    "http://www.example.com/image/481989943",
        "height": 125,
        "width":  100
    },
    "animated" : false,
    "ids": [116, 943, 234, 38793]
}
----

In the example, a _picture_ is represented as an object with two numerical properties ("width" and "height"), a string property ("title"), an object property ("thumbnail"), a boolean property ("animated") and an array of numbers property ("ids"). Nothing in the document indicates that it is describing a _picture_. The reason is that we are supposed to assign the data structure to a variable the name of which will tell us what the variable is about.

.Assigning a JSON structure to a variable in JavaScript
[source,javascript]
----
picture={
    "width":  800,
    "height": 600,
    "title":  "View from 15th Floor",
    "thumbnail": {
        "url":    "http://www.example.com/image/481989943",
        "height": 125,
        "width":  100
    },
    "animated" : false,
    "ids": [116, 943, 234, 38793]
}
----

Check on <<KVP_GET_client_request>> for the way to incorporate a JSON document into a JavaScript code on the fly.

=== If we had XML, why do we need JSON?
In the web, we find several comparisons between XML and JSON, some of them trying to do statistical analysis on some criteria, such as verbosity or performance. Some others (many, actually) are more based on opinions than in facts. This document will try to escape this debate and focus on practical facts.

XML was designed by a consensus process in several Internet groups and became a W3C recommendation on February 10th, 1998 as a document standard completely independent from any programming language. Since then, hundreds of document formats based on XML syntax had been proposed, including RSS, Atom, SOAP, and XHTML, Office Open XML, OpenOffice.org, Microsoft .NET Framework and many others. OGC has adopted XML for most of its web service messages and for several data formats, including GML, WaterML, SensorML, GUF, etc. XML has some interesting additional components: XML Schema/RelaxNG/Schematon provide ways to restrict the classes and data types to a controlled set of them. Actually, all document formats cited before provide a some form of schema document that accompanies the standard document. By providing schema files, standards incorporate a very simple way to check if a document follows the standard data model: a process executed by automatic tools that is called "XML validation". Other components of XML family are XPath (a query language), XSL transformations, etc. With time, these components have been implemented in many programming languages and tools.

JSON history is completely different. JSON was introduced in 1999 as a subset of the JavaScript language that extracted the essentials for defining data structures. This original idea is stated in the RFC7159: "JSON's design goals were to be minimal, portable, textual, and a subset of JavaScript". After 2005, JSON became popular and is used in the APIs of many web services offered by big companies on the web, such as Yahoo or Google. Currently, JSON is no longer restricted to web browsers, because JavaScript can now be used in web services and in stand alone applications (e.g. using node.js) and also because there are libraries that can read and write JSON for almost every programming language (see a long list of programming languages that have some sort of JSON libraries on json.org). 

==== The secret of JSON success in the web
Even if this is a matter of opinion, there are some practical reasons that helped to make JSON the favorite data encoding to many people.

* XML is not easy to learn. JSON format is so simple that can be explained in a few lines (as has been done in <<The_JSON_format>>). XML requires some knowledge about namespaces and namespace combinations. It also requires some knowledge about classes, complex data types, class generalizations, etc. None of this is present in JSON.
* XML is defined extensible, but XSD Schema validation is very restrictive in extensibility (at least in the way is used in the OGC standards). In practice, extension points need to be "prepared" by the designer of the original standard to be extended. For example, adding an element to a class in a non initially foreseen place results in a error in validation. In many occasions the only solution is changing the class name by generalization, giving up descend compatibility. In that sense, RelaxNG validation was designed with extensibility in mind but is not commonly used yet (it is now the recommended validation language for Atom feeds and OWS Context Atom encoding). JSON is used in a way that it can be extended (e.g. adding properties to objects is allowed without breaking compatibility). By default, JSON schema (see <<JSON_Schema>>) respects this extensibility.
* JSON relies on the simplicity of JavaScript in three important ways
** JSON (and JavaScript) have a very limited set of data types. All numbers are "Number" (there is no distinction between float, integer, long, byte,...) and all strings are "String". Arrays and Objects are almost identical; actually Arrays are Objects with numerical consecutive property names.
** In JavaScript, a JSON document can be converted in an JavaScript data structure (e.g. an object tree) with a single function, instead of a complicated chain of XML DOM data access function calls for each property needed to extract from an XML document. Unfortunately, this has nothing to do with XML or JSON, but in the way the XML DOM was initially implemented. Nevertheless, it has influenced the view that "JSON is simple; XML is complicated".
** JSON objects does not rely on explicit classes and data types. Even the concept of "data constructor" that was present in early versions of JavaScript it is not recommended anymore. Objects are created on the fly and potentially all objects in JSON (and in JavaScript) have a different data structure. However, in practical implementations, many objects and object arrays will mimic the same common pattern.
** JSON objects can be direct inputs of JavaScript API functions simplifying extensibility of APIs. All JavaScript functions can potentially have a very limited number of parameters, if some of them are JSON objects. New optional parameters can be introduced to these objects without changing the API.

As you will discover in the next sections of this document, a rigorous application of JSON in OGC services will require to adopt new additions to JSON, such as JSON validation and JSON-LD resulting in a no-so-simple JSON utilization.

== From JSON to JSON-LD
=== What is JSON-LD
JSON-LD is a lightweight syntax to encode Linked Data in JSON. Its design allows existing JSON to be interpreted as Linked Data with minimal changes. JSON-LD is 100% compatible with JSON. JSON-LD introduces a universal identifier mechanism for JSON via the use of URIs, a way to associate data types with values.

JSON-LD is considered another RDF encoding, for use with other Linked Data technologies like SparQL. Tools are available to transform JSON-LD into other RDF encodings like Turtle (such as the http://json-ld.org/playground/[JSON-LD playground]).

The authors of this document perceive the current documentation of JSON-LD as confusing. That is why another approach in explaining how to use JSON-LD is exposed here.

[[Apply_JSONLD_to_JSON_objects_subsection]]
=== Applying JSON-LD to JSON objects: minimum example
The main objective of JSON-LD is to define object identifiers and data types identifiers, on top of JSON objects. The identifiers used for objects and data types are unique URIs that provide extra semantics because they reuse definitions on the web (semantic web). 

First of all, JSON-LD defined two specific properties for each object: @id and @type that can be populated with the identifier of the object and the complex data type identifier of the JSON object. Please note that even if JSON (and javascript) does NOT provide classes, in JSON-LD we assign a class name (a.k.a. data type) to an object. In this example we start by defining the Mississippi river.

.Minimum example of a river object as a JSON-LD object
[source,json]
----
{
    "@id": "http://dbpedia.org/page/Mississippi_River",
    "@type": "http://dbpedia.org/ontology/River"
}
----

The conversion to RDF results in a single triple stating that the Mississippi river is of a river type.

.Conversion to the minimum example of a river object to RDF triples
[source,xml]
----
<http://dbpedia.org/page/Mississippi_River> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://dbpedia.org/ontology/River> .
----

[NOTE]
====
In this section, all conversions to RDF triples have been derived automatically for the JSON-LD precedent examples using the JSON-LD playground
====


=== JSON-LD encoding for JSON objects properties

To add a property to the Mississippi river we should define the semantics of the property by associating a URI to it. To do this we need to add also a @context property. Here we have two possibilities:
* reuse a preexisting vocabulary
* create our own vocabulary

In this example we are adding a _name_ to a river resulting on a second triple associated to the object id. In this case we reuse the schema.org vocabulary to define the semantics of the word _name_. Note that http://schema.org/ is actually a URL to a JSON-LD @context document that is in the root of the web server defining the actual and complete schema.org vocabulary.

.Adding a name property to JSON-LD object using a preexisting vocabulary
[source,json]
----
{
    "@context": "http://schema.org/",
    "@id": "http://dbpedia.org/page/Mississippi_River",
    "@type": "http://dbpedia.org/ontology/River",
    "name": "Mississippi river"
}
----

.Conversion to a river object with name to RDF triples
[source,xml]
----
<http://dbpedia.org/page/Mississippi_River> <http://schema.org/name> "Mississippi river" .
<http://dbpedia.org/page/Mississippi_River> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://dbpedia.org/ontology/River> .
----

As a second alternative, when the appropriate vocabulary in the JSON-LD format is not available, we can define the needed term on-the-fly as embedded content in the @context section of the JSON instance.

.Adding a name property to JSON-LD object defined elsewhere
[source,json]
----
{
    "@context": {
        "name": "http://www.opengis.net/def/ows-common/name"
    },
    "@id": "http://dbpedia.org/page/Mississippi_River",
    "@type": "http://dbpedia.org/ontology/River",
    "name": "Mississippi river"
}
----

It is also possible to combine two vocabularies, one preexisting and another embbeded. This could be particularly useful if, in the future, OWS common decides to release a vocabulary for OGC and OGC concrete services need to extend it. Note that, in this case, @context is defined as an array of an external vocabulary and an internal enumeration of property definitions (in the following example an enumeration of one element).

.Two properties defined combining the two alternatives described before
[source,json]
----
{
    "@context": ["http://schema.org/", {
        "bridges": "http://www.opengis.net/def/ows-common/river/bridge"
    }],
    "@id": "http://dbpedia.org/page/Mississippi_River",
    "@type": "http://dbpedia.org/ontology/River",
    "name": "Mississippi river",
    "bridges": ["Eads Bridge", "Chain of Rocks Bridge"]
}
----

.Conversion to a river object with name and bridges to RDF triples
[source,xml]
----
<http://dbpedia.org/page/Mississippi_River> <http://schema.org/name> "Mississippi river" .
<http://dbpedia.org/page/Mississippi_River> <http://www.opengis.net/def/ows-common/river/bridge> "Chain of Rocks Bridge" .
<http://dbpedia.org/page/Mississippi_River> <http://www.opengis.net/def/ows-common/river/bridge> "Eads Bridge" .
<http://dbpedia.org/page/Mississippi_River> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://dbpedia.org/ontology/River> .
----

=== Using namespaces in JSON-LD

Now we can refine the example and provide a more elegant encoding introducing the definition of abbreviated namespaces and their equivalent URI namespace.

.Using abbreviated namespaces in JSON-LD
[source,json]
----
{
    "@context": ["http://schema.org/", {
        "owscommon":"http://www.opengis.net/def/ows-common/",
        "page": "http://dbpedia.org/page/",
        "dbpedia": "http://dbpedia.org/ontology/",
        "bridges": "owscommon:river/bridge"
    }],
    "@id": "page:Mississippi_River",
    "@type": "dbpedia:River",
    "name": "Mississippi river",
    "bridges": ["Eads Bridge", "Chain of Rocks Bridge"]
}
----

=== Defining data types for properties in JSON-LD

By default, JSON-LD considers properties as strings. JSON-LD also permits to define data types not only for the objects but also for individual properties. It is common to define numeric data types.

.Adding data types to properties
[source,json]
----
{
    "@context": ["http://schema.org/", {
        "owscommon":"http://www.opengis.net/def/ows-common/",
        "page": "http://dbpedia.org/page/",
        "dbpedia": "http://dbpedia.org/ontology/",
        "bridges": "owscommon:river/bridge",
		"length": {
			"@id": "http://schema.org/distance",
			"@type": "xsd:float"
    	}
    }],
    "@id": "page:Mississippi_River",
    "@type": "dbpedia:River",
    "name": "Mississippi river",
    "bridges": ["Eads Bridge", "Chain of Rocks Bridge"],	
    "length": 3734
}
----

.Conversion of the length of a river object to RDF triples
[source,xml]
----
<http://dbpedia.org/page/Mississippi_River> <http://schema.org/distance> "3734"^^<http://www.w3.org/2001/XMLSchema#float> .
[...]
----

=== Ordered and unordered arrays in JSON-LD

An interesting aspect of JSON-LD is that it overwrites the behavior of JSON arrays. In JSON, arrays of values are sorted _lists_ but in JSON-LD arrays are _sets_ with no order. This way, in the previous examples, _bridges_ is an array but the conversion to RDF is done in a way that "Eads Bridge" and "Chain of Rocks Bridge" are associated with the Mississippi river with no order. In general, this is not a problem because most arrays are only _sets_ of values. Nevertheless, sometimes order is important for example in list of coordinates representing a line or a polygon border (imagine what could happen if only one coordinate is out or order!!). Fortunately, there is a way to declare that the array values order is important: using "@container": "@list".

.Example where the order of the list of bridges is important
[source,json]
----
{
    "@context": ["http://schema.org/", {
        "owscommon":"http://www.opengis.net/def/ows-common/",
        "page": "http://dbpedia.org/page/",
        "dbpedia": "http://dbpedia.org/ontology/",
        "bridges": {
          	"@id": "owscommon:river/bridge",
            "@container": "@list"
        }
   }],
    "@id": "page:Mississippi_River",
    "@type": "dbpedia:River",
    "name": "Mississippi river",
    "bridges": ["Eads Bridge", "Chain of Rocks Bridge"]
}
----

.Transformation to RDF of a list of bridges where order is important triples
[source,json]
----
<http://dbpedia.org/page/Mississippi_River> <http://schema.org/name> "Mississippi river" .
<http://dbpedia.org/page/Mississippi_River> <http://www.opengis.net/def/ows-common/river/bridge> _:b0 .
<http://dbpedia.org/page/Mississippi_River> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://dbpedia.org/ontology/River> .
_:b0 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> "Eads Bridge" .
_:b0 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> _:b1 .
_:b1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> "Chain of Rocks Bridge" .
_:b1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> <http://www.w3.org/1999/02/22-rdf-syntax-ns#nil> .
----

Please note that lists of lists are not allowed in JSON-LD making impossible to transform bidimensional arrays of coordinates. This issue is being discussed in <<Geospatial_dimension_in_JSON>>.

An special kind of data type is "@id". This indicates that a property points to another object _id_ that can be in the same document or elsewhere in the linked data web. This is the way that JSON-LD is able to define links between objects as previously discussed in <<JSON-LD_links_subsection>>.

[source,json]
----
{
    "@context": ["http://schema.org/", {
        "owscommon":"http://www.opengis.net/def/ows-common/",
        "page": "http://dbpedia.org/page/",
        "dbpedia": "http://dbpedia.org/ontology/",
        "wiki": "http://en.wikipedia.org/wiki/Mississippi_River",
		"describedBy": {
			"@id": "http://www.iana.org/assignments/relation/describedby",
			"@type": "@id"
		}        
    }],
    "@id": "page:Mississippi_River",
    "@type": "dbpedia:River",
    "name": "Mississippi river",
    "describedBy":  "wiki:Mississippi_River"
}
----

.Conversion to a river object related to another object to RDF triples
[source,xml]
----
<http://dbpedia.org/page/Mississippi_River> <http://schema.org/name> "Mississippi river" .
<http://dbpedia.org/page/Mississippi_River> <http://www.iana.org/assignments/relation/describedby> <http://en.wikipedia.org/wiki/Mississippi_RiverMississippi_River> .
<http://dbpedia.org/page/Mississippi_River> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://dbpedia.org/ontology/River> .
----

=== The geometrical dimension in JSON
One of the main purposes of OGC is providing ways to represent the geospatial dimension of data; a representation for geometries. In the past, OGC has done this in several ways, some of the most recognized ones are:

* GML (Geographic Markup Language): a XML encoding for geospatial features exchange that mainly focus on providing geospatial primitives encoded in XML. Other XML encodings use it as a basis, such as CityGML, WaterML, O&M, IndoorML, etc.
* KML: a XML encoding for vector features, mainly focused on presentation in a virtual globe.
* WKT (Well Known Text): a textual encoding for vector features, to be used in geospatial SQL or SparQL queries and in OpenSearch Geo.
* GeoRSS: a XML encoding for inserting geospatial geometries in RSS and atom feeds.
* GeoSMS: a compact textual encoding for positions in SMS messages.

For the moment, there is no agreement for JSON encoding for geospatial features in OGC. This section discusses several alternatives.

==== Modeling features and geometries
The ISO 19109 _General Feature Model_ discusses aspects of defining  features. The ISO 19109 is generally accepted by the OGC community that includes many of its concepts in the http://portal.opengeospatial.org/files/?artifact_id=29536[OGC 08-126 _The OpenGISÂ® Abstract Specification Topic 5: Features_].

Next figure describes the most abstract level of defining and structuring geographic data. In the context of a geographic application, the real world phenomena are classified into feature types that share the same list of attribute types. This means that if, for example, the geographical application is capturing protected areas, a _protected area_ feature type will define the attributes to capture it and all protected areas will share the same data structure.

[[The_process_from_universe_of_discourse_to_data]]
.The process from universe of discourse to data
image::images/The_process_from_universe_of_discourse_to_data.png[]

In practice, and following the same example, this means that there will be a _feature catalogue_ where an abstract _protected area_ is defined as having a multi-polygon, a list of ecosystem types, a list of ecosystem services, a elevation range, a year of definition and the figure of protection used, etc.

[[From_reality_to_geographic_data_image]]
.From reality to geographic data
image::images/19109_From_reality_to_geographic_data.png[]

This feature type will be formalized in an application schema. Here, we present a table as a formal way to define the attributes of the protected areas _feature type_.

.Protected area feature type attributes
[width="100%",options="header"]
|====================
| Attribute | Type | Multiplicity
| Official border | Multi-polygon | one
| Influence area | Multi-polygon | one
| Name | String | one or more
| Ecosystem type | String | one or more
| Ecosystem service | String | one or more
| Elevation range | Float | two
| Year of definition | Integer | zero or one
| Figure of protection | String | zero or one
|====================

This way of defining features is basic for the OGC community. GML have included the concept of the application schema from its earlier versions (i.e. an XML Schema). Nevertheless, there are formats that does not follow explicitly the same approach. For example, GeoRSS uses a fixed structure for attributes (common for all features; whatever the feature type) and adds a geometry. KML did not included the capacity to group features in features types until version 2.2 (the first OGC adopted community standard), and this version 2 is the first one to allow more that one property per feature. It includes a <Schema> tag to define feature types and its property names in a section of the document. Later, the feature type names can be used in PlaceMarks as part of the "ExtentedData/SchemaData" tag.

In the next subsections we will see how JSON can be used in different ways, some of them being compliant to the ISO General Feature Model.

==== GeoJSON
After years of discussion, in August 2016 the IETF RFC7946 was released, describing the GeoJSON format. GeoJSON is self-defined as "a geospatial data interchange format based on JSON. It defines several types of JSON objects and the manner in which they are combined to represent data about geographic features, their properties, and their spatial extents."

It defines the following object types "Feature", "FeatureCollection, "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", and "GeometryCollection".

GeoJSON presents some contradictions about complex data types: JSON has no object type concept but GeoJSON includes a "type" property in each object it defines, to declare the type of the object. In contrast, GeoJSON does not include the concept of _feature type_, in the GFM sense, as will be discussed later.

GeoJSON presents a feature collection of individual features. Each Feature has, at least 3 "attributes": a fixed value "type" ("type":"Feature"), a "geometry" and a "properties". Geometry only have 2 "attributes": "type" and "coordinates":

* "type" can be: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", and   "GeometryCollection". 
* "coordinates" is based in the idea of position. A position is an array of 2 [long, lat] or 3 numbers [long, lat, h]. The data type of "coordinates" depends on the type of "geometry":

** in Point, "coordinates" is a single position
** in a LineString or MultiPoint, "coordinates"  is an array of positions
** in a Polygon or MultiLineString, "coordinates" is an array of LineString or linear ring 
** in a MultiPolygon, "coordinates" is an array of Polygon 

There is no specification on what "properties" can contain so implementors are free to provide feature description composed by several attributes in it.

.Example of GeoJSON file describing a protected area (coordinates are dummy)
[source,json]
----
{
    "type": "FeatureCollection",
    "features": [{
        "type": "Feature",
        "geometry": {
            "type": "MultiPolygon",
            "coordinates": [
              [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
              [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
               [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
              ]
        },
        "id": "http://www.ecopotential.org/sierranevada",
        "bbox": [100.0, 0.0, 103.0, 3.0],
        "properties": {
            "name": "Sierra Nevada",
            "ecosystemType": "Mountain",
            "ecosystemService": ["turism", "biodiversity reserve"],
            "elevationRange": [860, 3482],
            "figureOfProtection": "National park"
        }
    }
}
----

===== GeoJSON particularities

A list of considerations extracted from the RFC 7946 require our attention:

* Features can have ids: "If a Feature has a commonly used identifier, that identifier SHOULD be included as a member of the Feature object with the name _id_"
* Features can have a "bbox": "a member named _bbox_ to include information on the coordinate range. The value of the bbox member MUST be an array of numbers, with all axes of the most southwesterly point followed by all axes of the more northeasterly point."
* Coordinates are in CRS84 + optional _ellipsoidal_ height. "The coordinate reference system for all GeoJSON coordinates is a geographic coordinate reference system, using the World Geodetic System 1984 (WGS 84) [WGS84] datum, with longitude and latitude units of decimal degrees. This is equivalent to the coordinate reference system identified by the Open Geospatial Consortium (OGC) URN urn:ogc:def:crs:OGC::CRS84. An OPTIONAL third-position element SHALL be the height in meters above or below the WGS 84 reference _ellipsoid_."
* "Members not described in RFC 7946 ("foreign members") MAY be used in a GeoJSON document." 
* GeoJSON elements cannot be recycled in other places: "GeoJSON semantics do not apply to foreign members and their descendants, regardless of their names and values."
* The GeoJSON types cannot be extended: "Implementations MUST NOT extend the fixed set of GeoJSON types: FeatureCollection, Feature, Point, LineString, MultiPoint, Polygon, MultiLineString, MultiPolygon, and GeometryCollection."
* "The media type for GeoJSON text is _application/geo+json_"

GeoJSON honors the simplicity of the JSON and JavaScript origins. GeoJSON defines _Feature collections_ and _Features_ but does not contemplate the possibility of defining Feature types or associating a Feature to a feature type. In our opinion this is consistent with JSON itself, that does not include the _data type_ concept, but diverges from the General Feature Model (GFM). In practice, this means that the number and type of the properties of each feature can be different. With this level of flexibility, GeoJSON is not the right format for exchanging data between repositories based on the GFM. In the introduction, RFC7946 compares GeoJSON with WFS outputs. This comparison is an oversimplification; even if the response of a WFS return a feature collection, RFC7946 overlooks that WFS deeply uses the _Feature Type_ concept that is missing in GeoJSON.

==== OGC needs that GeoJSON does not cover
In GeoJSON:

* There is no feature model. Sometimes there is the question about GeoJSON covering the OGC GML Simple Features. This is not the case: GML Simple Features uses the GFM in a simplified way but GeoJSON ignores the GFM.
* There is no support for CRSs other than CRS84.
* The geometries cannot be extended to other types.
* There is no support for the time component. 
* There is no information on symbology.

In practice, this means that GeoJSON can only be used in similar circumstances where KML can be used (but without symbology). GeoJSON cannot be used in the following use cases:

* When there is a need to communicate features that are based on the GFM and that depend on the feature type concept.
* When there is a need to communicate features that need to be represented in other CRS that CRS84, such as the combination of UTM/ETRS89.
* When the time component needs to be considered as a coordinate.
* When Simple geometries are not enough and there is a need for circles, arcs of circle, 3D meshes, etc.
* When coverage based (e.g. imagery) or O&M based (e.g. WaterML) data need to be communicated.
* When there is a need to use JSON-LD and to connect to the _linked data_.

In these cases there are three possible options:

* Simplify our use case until it fits in the GeoJSON requirements (see <<Simplify_our_use_case>>)
* Extend GeoJSON. In the "feature" or in the "properties" element of each FeatureCollection, include everything not supported by the GeoJSON (see <<Extend_GeoJSON>>)
* Deviate completely from the GeoJSON and use another JSON model for geometries (see <<Another_JSON_model_for_geometries>>)

Lets explore these possibilities on one by one.

[[Simplify_our_use_case]]
===== Simplify our use case until it fits in the GeoJSON requirements

In our opinion, GeoJSON is not an exchange format (as said by the RFC7946) but a visualization format ideal for representing data in web browsers. In that sense, the comparison in RFC7946 introduction with KML is appropriate. As said before, JSON lacks any visualization/portrayal instructions so symbolization will be applied in the client site or will be transmitted in an independent format.

In case where GeoJSON is a possible output of our information (complemented by other data formats), there is no problem on adapting our data model to the GeoJSON requirements (even if we are going to lose some characteristics) because we also offer other alternatives. In these scenarios, we will not recommend the GeoJSON format as a exchange format but as a visualization format. In OGC services, a WMS could server maps in GeoJSON and WFS can consider GeoJSON as one of the provided formats.

This is the way we can simplify our requirements to adapt them to JSON:

* Even if features are of the same feature type and share a common structure, we forget about this when transforming to JSON. 
* If there is more than one geometric property in the features, select one geometric property for the geometries and remove the rest. 
* Move all other feature properties inside the "properties" attribute. This will include, time, feature metadata, symbolization attributes, etc.
* Convert your position to CRS84.
* Convert any geometry that can not be directly represented in GeoJSON (e.g a circle) to a sequence of vertices and lines.

[[Extend_GeoJSON]]
===== Extend GeoJSON
The GeoJSON extensibility is limited by the interpretation of the sentence in the IETF standard "Implementations MUST NOT extend the fixed set of GeoJSON types: FeatureCollection, Feature, Point, LineString,  MultiPoint, Polygon, MultiLineString, MultiPolygon, and GeometryCollection.". The sentence is a bit ambiguous but, in general, you are allowed to include any content in the "properties" section, and there is no clear objection on adding attributes to "feature" (even most GeoJSON parsers will ignore them). It seems that you are neither allowed to invent new geometries nor to modify the current existing ones. With this limitations in mind, be can do several things, including the ones covered in the following subsections.

====== Adding visualization to GeoJSON
For some people, visualization is an important aspect that should be in GeoJSON and has provided some approach for including visualization styles.

* An style extension from MapBox includes terms in "properties" of the "Feature"s.
https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0

.Mapbox simplestyle-spec to add some styles to GeoJSON
[source,json]
----
{
    "type": "FeatureCollection",
    "features": [{ "type": "Feature",
        "geometry": {
            "type": "Polygon",
            //...
        },
        "properties": {
            "stroke": "#555555",
            "stroke-opacity": 1.0,
            "stroke-width": 2,
            "fill": "#555555",
            "fill-opacity": 0.5
        }
    }]
}
----

* Leaflet.geojsonCSS is an extension for Leaflet to support rendering GeoJSON with css styles in a "style" object in "Feature".
https://github.com/albburtsev/Leaflet.geojsonCSS

.Leaflet.geojsonCSS to add some styles to GeoJSON
[source,json]
----
{
    "type": "FeatureCollection",
    "features": [{ "type": "Feature",
        "geometry": {
            "type": "Polygon",
        },
        "style": {
            "color": "#CC0000",
            "weight": 2,
            "fill-opacity": 0.6,
            "opacity": 1,
            "dashArray": "3, 5"
        },
        "properties": {
            //...
        }
    }]
}
----

[[Other_CRS_representation_geometry]]
====== Other CRS representation for the same geometry
Sometimes it could be necessary to distribute your data in other CRSs that are not CRS84. As long as you are not doing this in the "geometry" part of the GeoJSON, you are allowed to do this. You can even reuse the _geometry_ object in the _properties_ section, knowing that they will be not considered by pure GeoJSON parsers.

.Example of GeoJSON file describing a protected area also in EPSG:25831 (coordinates are dummy).
[source,json]
----
{
    "type": "FeatureCollection",
    "features": [{
        "type": "Feature",
        "geometry": {
            "type": "MultiPolygon",
            "coordinates": [
              [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
              [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
               [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
              ]
        },
        "id": "http://www.ecopotential.org/sierranevada",
        "bbox": [100.0, 0.0, 103.0, 3.0],
        "bboxCRS": {
            "bbox": [500100.0, 4600000.0, 500103.0, 4600003.0],
            "crs": "http://www.opengis.net/def/crs/EPSG/0/25831",
        }
        "properties": {
            "geometryCRS": {
                "type": "MultiPolygon",
                "crs": "http://www.opengis.net/def/crs/EPSG/0/25831",
                "coordinates": [
                  [[[500102.0, 4600002.0], [500103.0, 4600002.0], [500103.0, 4600003.0], [500102.0, 4600003.0], [500102.0, 4600002.0]]],
                  [[[500100.0, 4600000.0], [500101.0, 4600000.0], [500101.0, 4600001.0], [500100.0, 4600001.0], [500000.0, 4600000.0]],
                   [[500100.2, 4600000.2], [500100.8, 4600000.2], [500100.8, 4600000.8], [500100.2, 4600000.8], [500100.2, 4600000.2]]]
                  ]
            },        
            "name": "Sierra Nevada",
            "ecosystemType": "Mountain",
            "ecosystemService": ["turism", "biodiversity reserve"],
            "elevationRange": [860, 3482],
            "figureOfProtection": "National park"
        }
    }
}
----

[[Another_JSON_model_for_geometries]]
===== Another JSON model for geometries
The last alternative is to completely forget about GeoJSON and define your own encoding strictly following the GFM.

.Example of JSON file describing a protected area without using GeoJSON (coordinates are dummy).
[source,json]
----
{
    "id": "http://www.ecopotential.org/sierranevada",
    "featureType": "ProtectedArea",
    "officialBorder": {
        "type": "MultiPolygon",
        "crs": "http://www:opengis.net/def/crs/OGC/1/3/CRS84",
        "coordinates": "[
          [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
          [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
           [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
          ]"
    }
    "infuenceArea": {
        "type": "MultiPolygon",
        "crs": "http://www:opengis.net/def/crs/OGC/1/3/CRS84",
        "coordinates": "[
          [[[99.0, 1.0], [113.0, 1.0], [113.0, 5.0], [99.0, 5.0], [99.0, 1.0]]],
          [[[80.0, -10.0], [110.0, -10.0], [110.0, 11.0], [80.0, 11.0], [90.0, -10.0]],
           [[90.2, -0.2], [108.8, -0.2], [108.8, 1.8], [108.2, 1.8], [90.2, -0.2]]]
          ]"
    }
    "name": "Sierra Nevada",
    "ecosystemType": "Mountain",
    "ecosystemService": ["turism", "biodiversity reserve"],
    "elevationRange": [860, 3482],
    "figureOfProtection": "National park"    
}
----

The previous example has been defined in a way that is compatible with JSON-LD and can be automatically converted to RDF if a @context is provided. Please, note that coordinates are expressed as strings to force a JSON-LD engine to ignore them and consider them string. This notation has been suggested in OGC 16-051 JavaScript JSON JSON-LD ER. We call it JSON double encoding as the string is written in a notation that is fully compatible with JSON and the content of "coordinates" can be parsed into a JSON object and converted into a multidimensonal array easily.

====== JSON for coverages
Since the first versions of the HTML and web browsers, it was possible to send a JPEG or a PNG to the browser and show it. With addition of HTML DIV tags, it was possible to overlay them in a layer stack and show them. WMS took advantage of it to create map browsers on the web. The main problem with this approach was that the "map" could not be manipulated in the client, so symbolization of the map had to be done in the server (and the interaction with the data became slow and limited. Modern web browsers implementing HTML5 allow for controlling pixel values on the screen representation in what is called the _canvas_. This capability allows sending an array of values from a coverage server to web browser that can be converted into a RGBA array and then represented in the canvas. This represents an evolution of what was possible in the past. By implementing this strategy it is possible to control the coloring of "maps" directly in the browser and to make queries on the actual image values in the client. The map becomes a true coverage.

A good coverage need to be defined by an small set of metadata that defines the domain (the grid) the range values (the data) and the range meaning (the data semantics). This is exactly what the Coverage Implementation Schema (CIS) is doing (formerly known as GMLCov).

The idea of creating a JSON GMLCov associated to a JSON coverage appears for the first time in the section 9 of the OGC 15-053r1 Testbed-11 Implementing JSON/GeoJSON in an OGC Standard Engineering Report. This idea was taken by the MELODIES FP7 project (http://www.melodiesproject.eu/), and described as a full specification, as well as implemented as an extension of the popular map browser _Leaflet_. The description of the approach can be found here https://github.com/covjson/specification. A complete demostration on how it works can be found here: https://covjson.org/playground/ (tested with Chrome).

[[Coverages_JSON_Playground]]
.CoveragesJSON playground dummy example for continuous values in http://covjson.org
image::images/coveragesJSONplayground.png[]

CoverageJSON is a demonstration of what can be done with coverages in the browsers. On our opinion, this approach will improve the user experience working with imagery and other types of coverages in web browsers. Unfortunately, the CoverageJSON defined by MELODIES deviates significantly from the OGC CIS. Actually CoverageJSON redesigns CIS to replicate most of the concepts in a different way and adds some interesting new concepts and functionalities of its own. 

To better align with OGC coverages representation, a new JSON encoding is introduced in the OGC CIS 1.1. In this case, the JSON encoding strictly follows the new CIS 1.1 UML model. This encoding is presented in section 13 on CIS 1.1 and includes a set of JSON schemas. In addition, section 14 adds requirements for JSON-LD that are complemented by JSON-LD context files. Several examples are also informative material accompanying the CIS 1.1 document. More details can be found also in this ER: OGC 16-051 JavaScript JSON JSON-LD ER

.Example of a regular grid represented as a CIS JSON file [source,json]
----
{
	"@context": ["http://localhost/json-ld/coverage-context.json", {"examples": "http://www.opengis.net/cis/1.1/examples/"}],
	"type": "CoverageByDomainAndRangeType",
	"id": "examples:CIS_10_2D",
	"domainSet":{
		"@context": "http://localhost/json-ld/domainset-context.json",
		"type": "DomainSetType",
		"id": "examples:CIS_DS_10_2D",
		"generalGrid":{
			"type": "GeneralGridCoverageType",
			"id": "examples:CIS_DS_GG_10_2D",
			"srsName": "http://www.opengis.net/def/crs/EPSG/0/4326",
			"axisLabels": ["Lat", "Long"],
			"axis": [{ 
				"type": "RegularAxisType",
				"id": "examples:CIS_DS_GG_LAT_10_2D",
				"axisLabel": "Lat",
				"lowerBound": -80,
				"upperBound": -70,
				"uomLabel": "deg",
				"resolution": 5
			},{
				"type": "RegularAxisType",
				"id": "examples:CIS_DS_GG_LONG_10_2D",
				"axisLabel": "Long",
				"lowerBound": 0,
				"upperBound": 10,
				"uomLabel": "deg",
				"resolution": 5
			}],
			"gridLimits": {
				"type": "GridLimitsType",
				"id": "examples:CIS_DS_GG_GL_10_2D",
				"srsName": "http://www.opengis.net/def/crs/OGC/0/Index2D",
				"axisLabels": ["i", "j"],
				"axis": [{ 
					"type": "IndexAxisType",
					"id": "examples:CIS_DS_GG_GL_I_10_2D",
					"axisLabel": "i",
					"lowerBound": 0,
					"upperBound": 2
				},{
					"type": "IndexAxisType",
					"id": "examples:CIS_DS_GG_GL_J_10_2D",
					"axisLabel": "j",
					"lowerBound": 0,
					"upperBound": 2
				}]
			}
		}
	},
	"rangeSet": {
		"@context": "http://localhost/json-ld/rangeset-context.json",
		"type": "RangeSetType",
		"id": "examples:CIS_RS_10_2D",
		"dataBlock": {
			"id": "examples:CIS_RS_DB_10_2D",
			"type": "VDataBlockType", 
			"values": [1,2,3,4,5,6,7,8,9]
		}
	},
	"rangeType": { 
		"@context": "http://localhost/json-ld/rangetype-context.json",
		"type": "DataRecordType",
		"id": "examples:CIS_RT_10_2D",
		"field":[{ 
			"type": "QuantityType",
			"id": "examples:CIS_RT_F_10_2D",
			"definition": "ogcType:unsignedInt",
			"uom": {
				"type": "UnitReference",
				"id": "examples:CIS_RT_F_UOM_10_2D",
				"code": "10^0"
			}
		}]
	}  
}
----